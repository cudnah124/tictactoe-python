
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Caro Game - Play with Python</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        .cell {
            transition: all 0.3s ease;
        }
        .cell:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.5);
        }
        .winning-cell {
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { background-color: rgba(34, 197, 94, 0.3); }
            50% { background-color: rgba(34, 197, 94, 0.7); }
            100% { background-color: rgba(34, 197, 94, 0.3); }
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col">
    <header class="bg-blue-600 text-white shadow-lg">
        <div class="container mx-auto px-4 py-6">
            <div class="flex justify-between items-center">
                <h1 class="text-3xl font-bold">TIC - TAC - TOE</h1>
                <div class="flex space-x-4">
                    <button id="newGameBtn" class="bg-white text-blue-600 px-4 py-2 rounded-lg font-semibold hover:bg-blue-50 transition">
                        <i class="fas fa-plus mr-2"></i>New Game
                    </button>
                </div>
            </div>
        </div>
    </header>

    <main class="flex-grow container mx-auto px-4 py-8">
        <div class="flex flex-col lg:flex-row gap-8">
            <!-- Game Board -->
            <div class="flex-grow">
                <div class="bg-white rounded-xl shadow-lg p-6">
                    <div class="flex justify-between items-center mb-6">
                        <h2 class="text-2xl font-semibold text-gray-800">Game Board</h2>
                        <div id="status" class="text-lg font-medium text-gray-600">
                            Waiting to start...
                        </div>
                    </div>
                    
                    <div class="flex justify-center">
                        <div id="board" class="grid grid-cols-10 gap-1 bg-gray-200 p-2 rounded-lg">
                            <!-- Cells will be generated by JavaScript -->
                        </div>
                    </div>
                    
                    <div class="mt-6 flex justify-between items-center">
                        <div class="flex items-center space-x-4">
                            <div class="flex items-center">
                                <div class="w-8 h-8 bg-blue-500 rounded-full flex items-center justify-center text-white font-bold">X</div>
                                <span class="ml-2 text-gray-700">Player (You)</span>
                            </div>
                            <div class="flex items-center">
                                <div class="w-8 h-8 bg-red-500 rounded-full flex items-center justify-center text-white font-bold">O</div>
                                <span class="ml-2 text-gray-700">AI</span>
                            </div>
                        </div>
                        <div id="timer" class="text-xl font-mono bg-gray-100 px-4 py-2 rounded-lg">
                            00:00
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Game Info & Controls -->
            <div class="w-full lg:w-80">
                <div class="bg-white rounded-xl shadow-lg p-6 mb-6">
                    <h2 class="text-xl font-semibold text-gray-800 mb-4">Game Settings</h2>
                    
                    <div class="space-y-4">
                        <div>
                            <label class="block text-gray-700 mb-1">Board Size</label>
                            <select id="boardSize" class="w-full p-2 border border-gray-300 rounded-lg">
                                <option value="3">3x3 (Standard)</option>
                                <option value="5">5x5</option>
                                <option value="10">10x10</option>
                            </select>
                        </div>
                        
                        <div>
                            <label class="block text-gray-700 mb-1">Win Condition</label>
                            <select id="winCondition" class="w-full p-2 border border-gray-300 rounded-lg">
                                <option value="3">3 in a row</option>
                                <option value="4">4 in a row</option>
                                <option value="5">5 in a row</option>
                            </select>
                        </div>
                        
                        <div>
                            <label class="block text-gray-700 mb-1">Opponent</label>
                            <select id="difficulty" class="w-full p-2 border border-gray-300 rounded-lg">
                                <option value="ai" selected>AI</option>
                                <option value="human">Human</option>
                            </select>
                        </div>

                    </div>
                </div>
                
                <div class="bg-white rounded-xl shadow-lg p-6">
                    <div id="messageLog" class="h-40 overflow-y-auto bg-gray-100 p-3 rounded-lg text-sm font-mono text-gray-700">
                        <!-- Messages will appear here -->
                    </div>
                </div>
            </div>
        </div>
    </main>

    <footer class="bg-gray-800 text-white py-6">
        <div class="container mx-auto px-4 text-center">
            <p>TIC - TAC - TOE with Python AI - Created with HTML, CSS, JavaScript and Python</p>
        </div>
    </footer>

    <script>

        const gameState = {
            board: [],
            boardSize: 10,
            currentPlayer: 'X',
            gameActive: false,
            winner: null,
            winCondition: 5,
            timerInterval: null,
            secondsElapsed: 0,
            socket: null,
            connected: false,
            type: null
        };

        // DOM elements
        const boardElement = document.getElementById('board');
        const statusElement = document.getElementById('status');
        const timerElement = document.getElementById('timer');
        const newGameBtn = document.getElementById('newGameBtn');
        const connectBtn = document.getElementById('connectBtn');
        const boardSizeSelect = document.getElementById('boardSize');
        const winConditionSelect = document.getElementById('winCondition');
        const difficultySelect = document.getElementById('difficulty');
        const connectionStatus = document.getElementById('connectionStatus');
        const messageLog = document.getElementById('messageLog');
        const hostInfo = document.getElementById('hostInfo');
        const serverStatus = document.getElementById('serverStatus');

        // Initialize the game
        function initGame() {
              // Clear any existing game
              clearBoard();
              stopTimer();
              
              // Set game parameters
              gameState.boardSize = parseInt(boardSizeSelect.value);
              gameState.winCondition = parseInt(winConditionSelect.value);
              gameState.currentPlayer = 'X';
              gameState.gameActive = true;
              gameState.winner = null;
              gameState.secondsElapsed = 0;
              gameState.winCondition = parseInt(winConditionSelect.value);
              // Initialize empty board
              gameState.board = Array(gameState.boardSize).fill().map(() => Array(gameState.boardSize).fill(''));
              
              if (boardSizeSelect.value == 3) {
                  gameState.winCondition = 3;
                  gameState.type = 'reinforcement_learning'; // Default AI type for 3x3
              } else if (boardSizeSelect.value == 5) {
                  gameState.type = 'rule_based'; // Default AI type for 5x5
              } else if (boardSizeSelect.value == 10) {
                  gameState.type = 'rule_based'; // Default AI type for 10x10
              }
              // Create board UI
              renderBoard();
              
              // Start timer
              startTimer();
              fetch("http://127.0.0.1:5000/create_game", {
                method: "POST",
                headers: {
                        "Content-Type": "application/json"
                },
                body: JSON.stringify({
                        row: gameState.boardSize,
                        col: gameState.boardSize,
                        type: gameState.type,
                        wincondition: gameState.winCondition
                })
                })
                .then(response => response.json())
                .then(data => {
                    console.log("Init success");
                })
                .catch(err => console.error(err));
                
              // Update status
              updateStatus(`Your turn (X)`);
              
              // Add log message
              addLogMessage('New game started. Board size: ' + gameState.boardSize + 'x' + gameState.boardSize);
        }

        // Render the game board
        function renderBoard() {
            boardElement.innerHTML = '';
            boardElement.className = `grid gap-1 bg-gray-200 p-2 rounded-lg`;
            boardElement.style.gridTemplateColumns = `repeat(${gameState.boardSize}, minmax(0, 1fr))`;
            
            for (let i = 0; i < gameState.boardSize; i++) {
                for (let j = 0; j < gameState.boardSize; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell bg-white w-10 h-10 flex items-center justify-center text-2xl font-bold cursor-pointer rounded';
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    
                    if (gameState.board[i][j] === 'X') {
                        cell.textContent = 'X';
                        cell.classList.add('text-blue-500');
                    } else if (gameState.board[i][j] === 'O') {
                        cell.textContent = 'O';
                        cell.classList.add('text-red-500');
                    }
                    
                    cell.addEventListener('click', () => handleCellClick(i, j));
                    boardElement.appendChild(cell);
                }
            }
        }
        

        // Handle cell click
        function handleCellClick(row, col) {
            if (!gameState.gameActive || gameState.board[row][col] !== '' || gameState.currentPlayer !== 'X') {
                return;
            }
            
            // Make move
            makeMove(row, col, 'X');
            
            // Check for winner
            if (checkWinner(row, col, 'X')) {
                gameState.winner = 'X';
                endGame(`You win!`);
                return;
            }
            
            // Check for draw
            if (isBoardFull()) {
                endGame(`It's a draw!`);
                return;
            }
            
            // Switch to AI player
            gameState.currentPlayer = 'O';
            updateStatus(`AI's turn (O)`);
            
            // If connected to Python, send move
            if (gameState.connected) {
                sendMoveToServer(row, col);
            } else {
                // If not connected, use simple AI
                setTimeout(() => {
                    makeAIMove();
                }, 500);
            }
        }

        // Make a move on the board
        function makeMove(row, col, player) {
            gameState.board[row][col] = player;
            if (player == 'X'){
                fetch("http://127.0.0.1:5000/human_move", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                        x: row,
                        y: col,
                    })
                    })
                    .then(response => response.json())
                    .then(data => {
                        console.log("Init success");
                    })
                    .catch(err => console.error(err));
            }
            // Update UI
            const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            if (cell) {
                cell.textContent = player;
                cell.classList.add(player === 'X' ? 'text-blue-500' : 'text-red-500');
                cell.classList.remove('hover:bg-gray-100');
            }
            
            addLogMessage(`Player ${player} moved to (${row}, ${col})`);
        }

        // Simple AI move (fallback when not connected to Python)
        function makeAIMove() {
            if (!gameState.gameActive || gameState.currentPlayer !== 'O') {
                return;
            }
            
            // Find empty cell
            let emptyCells = [];
            for (let i = 0; i < gameState.boardSize; i++) {
                for (let j = 0; j < gameState.boardSize; j++) {
                    if (gameState.board[i][j] === '') {
                        emptyCells.push({row: i, col: j});
                    }
                }
            }
            if (emptyCells.length > 0) {
                // Random move for simplicity
                let row  = null
                let col = null
                async function aiTurn() {
                    
                    try {
                        const response = await fetch("http://127.0.0.1:5000/ai_move");
                        const data = await response.json();
                        [row, col] = data.ai_move;
                        makeMove(row, col, 'O');
                        return {row, col}
                    } catch (err) {
                        console.error("Fetch AI move error:", err);
                    }
                }

                async function handleAITurn() {
                    const move = await aiTurn();
                    if (!move) return;

                    // Lúc này row và col đã được cập nhật
                    const { row, col } = move;

                    // Check for winner
                    if (checkWinner(row, col, 'O')) {
                        gameState.winner = 'O';
                        endGame(`AI wins!`);
                        return;
                    }

                    // Check for draw
                    if (isBoardFull()) {
                        endGame(`It's a draw!`);
                        return;
                    }

                    // Switch back to human player
                    gameState.currentPlayer = 'X';
                    updateStatus(`Your turn (X)`);
                }

                // Gọi ở nơi cần chạy lượt AI
                handleAITurn();
            }
        }

        // Check for winner
        function checkWinner(row, col, player) {
            const directions = [
                [0, 1],   // horizontal
                [1, 0],   // vertical
                [1, 1],   // diagonal down-right
                [1, -1]   // diagonal down-left
            ];
            
            for (const [dx, dy] of directions) {
                let count = 1;
                
                // Check in positive direction
                for (let i = 1; i < gameState.winCondition; i++) {
                    const newRow = row + i * dx;
                    const newCol = col + i * dy;
                    if (newRow >= 0 && newRow < gameState.boardSize && 
                        newCol >= 0 && newCol < gameState.boardSize && 
                        gameState.board[newRow][newCol] === player) {
                        count++;
                    } else {
                        break;
                    }
                }
                
                // Check in negative direction
                for (let i = 1; i < gameState.winCondition; i++) {
                    const newRow = row - i * dx;
                    const newCol = col - i * dy;
                    if (newRow >= 0 && newRow < gameState.boardSize && 
                        newCol >= 0 && newCol < gameState.boardSize && 
                        gameState.board[newRow][newCol] === player) {
                        count++;
                    } else {
                        break;
                    }
                }
                
                if (count >= gameState.winCondition) {
                    // Highlight winning cells
                    highlightWinningCells(row, col, dx, dy, player);
                    return true;
                }
            }
            return false
        }

        // Highlight winning cells
        function highlightWinningCells(row, col, dx, dy, player) {
            const cells = [];
            
            // Find all cells in the winning line
            for (let i = -(gameState.winCondition - 1); i < gameState.winCondition; i++) {
                const newRow = row + i * dx;
                const newCol = col + i * dy;
                
                if (newRow >= 0 && newRow < gameState.boardSize && 
                    newCol >= 0 && newCol < gameState.boardSize && 
                    gameState.board[newRow][newCol] === player) {
                    cells.push({row: newRow, col: newCol});
                }
            }
            
            // Add winning class to each cell
            cells.forEach(cell => {
                const cellElement = document.querySelector(`[data-row="${cell.row}"][data-col="${cell.col}"]`);
                if (cellElement) {
                    cellElement.classList.add('winning-cell');
                }
            });
        }

        // Check if board is full
        function isBoardFull() {
            for (let i = 0; i < gameState.boardSize; i++) {
                for (let j = 0; j < gameState.boardSize; j++) {
                    if (gameState.board[i][j] === '') {
                        return false;
                    }
                }
            }
            return true;
        }

        // Update game status
        function updateStatus(message) {
            statusElement.textContent = message;
        }

        // End the game
        function endGame(message) {
            gameState.gameActive = false;
            updateStatus(message);
            stopTimer();
            addLogMessage(`Game ended: ${message}`);
        }

        // Clear the board
        function clearBoard() {
            boardElement.innerHTML = '';
            fetch("http://127.0.0.1:5000/reset", {
                method: "POST"
            })
            .then(response => response.json())
            .then(data => {
                console.log("Reset success");
            })
            .catch(err => {
                console.error("Fetch reset error:", err);
            });
        }

        // Timer functions
        function startTimer() {
            gameState.secondsElapsed = 0;
            updateTimerDisplay();
            gameState.timerInterval = setInterval(() => {
                gameState.secondsElapsed++;
                updateTimerDisplay();
            }, 1000);
        }

        function stopTimer() {
            if (gameState.timerInterval) {
                clearInterval(gameState.timerInterval);
                gameState.timerInterval = null;
            }
        }

        function updateTimerDisplay() {
            const minutes = Math.floor(gameState.secondsElapsed / 60);
            const seconds = gameState.secondsElapsed % 60;
            timerElement.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // Add message to log
        function addLogMessage(message) {
            const now = new Date();
            const timeString = now.toLocaleTimeString();
            const messageElement = document.createElement('div');
            messageElement.textContent = `[${timeString}] ${message}`;
            messageLog.appendChild(messageElement);
            messageLog.scrollTop = messageLog.scrollHeight;
        }

        // Event listeners
        newGameBtn.addEventListener('click', initGame);

        // Initialize on load
        document.addEventListener('DOMContentLoaded', () => {
            // Add welcome message
            const boardSizeSelect = document.getElementById("boardSize");
            const winConditionSelect = document.getElementById("winCondition");

            function updateWinConditionOptions() {
                const boardSize = parseInt(boardSizeSelect.value);
                winConditionSelect.innerHTML = ""; // clear options

                if (boardSize === 3) {
                    winConditionSelect.innerHTML = `<option value="3">3 in a row</option>`;
                } else if (boardSize === 5) {
                    winConditionSelect.innerHTML = `
                        <option value="4">4 in a row</option>
                    `;
                } else if (boardSize === 10) {
                    winConditionSelect.innerHTML = `
                        <option value="4">4 in a row</option>
                        <option value="5">5 in a row</option>
                    `;
                }
            }

            function updateBoardSizeOptions() {
                const winCondition = parseInt(winConditionSelect.value);
                const availableSizes = [];

                if (winCondition === 3) {
                    availableSizes.push(3, 5, 10);
                } else if (winCondition === 4) {
                    availableSizes.push(5, 10);
                } else if (winCondition === 5) {
                    availableSizes.push(10);
                }

                const currentValue = parseInt(boardSizeSelect.value);
                boardSizeSelect.innerHTML = "";
                for (const size of availableSizes) {
                    const option = document.createElement("option");
                    option.value = size;
                    option.textContent = `${size}x${size}`;
                    if (size === currentValue) option.selected = true;
                    boardSizeSelect.appendChild(option);
                }
            }

            // Liên kết 2 dropdown
            boardSizeSelect.addEventListener("change", updateWinConditionOptions);
            winConditionSelect.addEventListener("change", updateBoardSizeOptions);

            // Gọi ban đầu để khởi tạo
            updateWinConditionOptions();
            addLogMessage('Welcome to Caro Game! Click "New Game" to start.');
        });
    </script>
</body>
</html>